<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从输入URL到页面呈现发生了什么 | 会飞的鱼🐟</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="学习笔记">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.5fc96bdf.js" as="script"><link rel="preload" href="/assets/js/2.56cd01f5.js" as="script"><link rel="preload" href="/assets/js/12.644b56f9.js" as="script"><link rel="prefetch" href="/assets/js/10.3ea21215.js"><link rel="prefetch" href="/assets/js/11.f2af6ae8.js"><link rel="prefetch" href="/assets/js/13.321b16b6.js"><link rel="prefetch" href="/assets/js/14.c75e2d6b.js"><link rel="prefetch" href="/assets/js/15.5b62c749.js"><link rel="prefetch" href="/assets/js/16.1365c67d.js"><link rel="prefetch" href="/assets/js/17.b89f8d5a.js"><link rel="prefetch" href="/assets/js/18.c2b2881c.js"><link rel="prefetch" href="/assets/js/19.793ae888.js"><link rel="prefetch" href="/assets/js/20.ceb40dc7.js"><link rel="prefetch" href="/assets/js/21.3872ab50.js"><link rel="prefetch" href="/assets/js/22.cdd80890.js"><link rel="prefetch" href="/assets/js/23.b89f5df5.js"><link rel="prefetch" href="/assets/js/24.00cc879e.js"><link rel="prefetch" href="/assets/js/25.e7d9e711.js"><link rel="prefetch" href="/assets/js/26.38dfa295.js"><link rel="prefetch" href="/assets/js/27.42e5a51b.js"><link rel="prefetch" href="/assets/js/28.f29c5a5a.js"><link rel="prefetch" href="/assets/js/29.9c1152d0.js"><link rel="prefetch" href="/assets/js/3.5ad5b76e.js"><link rel="prefetch" href="/assets/js/30.fb98a7fd.js"><link rel="prefetch" href="/assets/js/31.587a4c4e.js"><link rel="prefetch" href="/assets/js/32.07d3f2a3.js"><link rel="prefetch" href="/assets/js/33.330ca2ab.js"><link rel="prefetch" href="/assets/js/34.644b8fec.js"><link rel="prefetch" href="/assets/js/35.2a59dd03.js"><link rel="prefetch" href="/assets/js/36.f24a64fb.js"><link rel="prefetch" href="/assets/js/37.4c48b883.js"><link rel="prefetch" href="/assets/js/38.e2ef6b4b.js"><link rel="prefetch" href="/assets/js/39.560ec89f.js"><link rel="prefetch" href="/assets/js/4.a64d0739.js"><link rel="prefetch" href="/assets/js/40.e9e6f1a1.js"><link rel="prefetch" href="/assets/js/41.c2b76d48.js"><link rel="prefetch" href="/assets/js/42.a837ca06.js"><link rel="prefetch" href="/assets/js/43.e6231a11.js"><link rel="prefetch" href="/assets/js/44.a06340cd.js"><link rel="prefetch" href="/assets/js/45.2e753f17.js"><link rel="prefetch" href="/assets/js/46.67d5bfd7.js"><link rel="prefetch" href="/assets/js/47.79d98f76.js"><link rel="prefetch" href="/assets/js/48.a27665a5.js"><link rel="prefetch" href="/assets/js/49.61035e35.js"><link rel="prefetch" href="/assets/js/5.05ac1e95.js"><link rel="prefetch" href="/assets/js/50.23d10ba5.js"><link rel="prefetch" href="/assets/js/51.ffd94a50.js"><link rel="prefetch" href="/assets/js/52.72645a49.js"><link rel="prefetch" href="/assets/js/53.fddcc9c3.js"><link rel="prefetch" href="/assets/js/54.29a19228.js"><link rel="prefetch" href="/assets/js/55.9dd56225.js"><link rel="prefetch" href="/assets/js/56.97ccbdc2.js"><link rel="prefetch" href="/assets/js/57.b5653684.js"><link rel="prefetch" href="/assets/js/58.5022402f.js"><link rel="prefetch" href="/assets/js/59.2788a4dc.js"><link rel="prefetch" href="/assets/js/6.2caff082.js"><link rel="prefetch" href="/assets/js/60.3a36e8b6.js"><link rel="prefetch" href="/assets/js/61.a58c0429.js"><link rel="prefetch" href="/assets/js/62.22142950.js"><link rel="prefetch" href="/assets/js/63.eb63df3a.js"><link rel="prefetch" href="/assets/js/64.5410a8b2.js"><link rel="prefetch" href="/assets/js/65.05534a28.js"><link rel="prefetch" href="/assets/js/66.345d568d.js"><link rel="prefetch" href="/assets/js/67.6d6c908d.js"><link rel="prefetch" href="/assets/js/68.48f8f647.js"><link rel="prefetch" href="/assets/js/69.0880f127.js"><link rel="prefetch" href="/assets/js/7.92af244d.js"><link rel="prefetch" href="/assets/js/70.6190682a.js"><link rel="prefetch" href="/assets/js/71.aef1621f.js"><link rel="prefetch" href="/assets/js/72.701beefb.js"><link rel="prefetch" href="/assets/js/73.5049b0f0.js"><link rel="prefetch" href="/assets/js/74.951b2541.js"><link rel="prefetch" href="/assets/js/75.a448589d.js"><link rel="prefetch" href="/assets/js/76.5245fdac.js"><link rel="prefetch" href="/assets/js/77.f76382e3.js"><link rel="prefetch" href="/assets/js/78.df1f1d7c.js"><link rel="prefetch" href="/assets/js/8.eef37b1f.js"><link rel="prefetch" href="/assets/js/9.e99284fe.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">会飞的鱼🐟</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basics/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/basics/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/basics/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><a href="/frame/" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/project-practice/" class="nav-link">
  项目实践
</a></div><div class="nav-item"><a href="/browser/" class="nav-link router-link-active">
  浏览器
</a></div><div class="nav-item"><a href="/computer/" class="nav-link">
  计算机基础
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/basics/javascript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/basics/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/basics/html/" class="nav-link">
  HTML
</a></li></ul></div></div><div class="nav-item"><a href="/frame/" class="nav-link">
  前端框架
</a></div><div class="nav-item"><a href="/engineering/" class="nav-link">
  前端工程化
</a></div><div class="nav-item"><a href="/project-practice/" class="nav-link">
  项目实践
</a></div><div class="nav-item"><a href="/browser/" class="nav-link router-link-active">
  浏览器
</a></div><div class="nav-item"><a href="/computer/" class="nav-link">
  计算机基础
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser/basics/url/" aria-current="page" class="active sidebar-link">从输入URL到页面呈现发生了什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser/basics/url/#网络过程" class="sidebar-link">网络过程</a></li><li class="sidebar-sub-header"><a href="/browser/basics/url/#解析过程" class="sidebar-link">解析过程</a></li><li class="sidebar-sub-header"><a href="/browser/basics/url/#渲染过程" class="sidebar-link">渲染过程</a></li></ul></li><li><a href="/browser/basics/repaint/" class="sidebar-link">重绘和回流</a></li><li><a href="/browser/basics/safe/" class="sidebar-link">安全策略</a></li><li><a href="/browser/basics/cache/" class="sidebar-link">缓存策略</a></li><li><a href="/browser/basics/local-store/" class="sidebar-link">本地存储</a></li><li><a href="/browser/basics/homology/" class="sidebar-link">同源策略</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>谷歌浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser/chrome/framework/" class="sidebar-link">Chrome架构</a></li><li><a href="/browser/chrome/performance/" class="sidebar-link">Performance</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="从输入url到页面呈现发生了什么"><a href="#从输入url到页面呈现发生了什么" class="header-anchor">#</a> 从输入URL到页面呈现发生了什么</h1> <p>这是一个可以无限难的问题</p> <p>此时此刻，假如在浏览器地址栏输入了百度的网址：<code>https://www.baidu.com/</code></p> <h2 id="网络过程"><a href="#网络过程" class="header-anchor">#</a> 网络过程</h2> <h3 id="网络请求"><a href="#网络请求" class="header-anchor">#</a> 网络请求</h3> <p><strong>1. 构建请求</strong></p> <p>浏览器会创建请求行</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span>
<span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>

</code></pre></div><p><strong>2. 查找强缓存</strong></p> <p>先检查强缓存，如果命中直接使用，否则进入下一步。关于强缓存，<a href="/browser/basics/cache/">浏览器缓存策略</a></p> <p><strong>3. DNS解析</strong></p> <p>由于我们输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和IP一一映射，我们将这个系统就叫做DNS（域名系统）。得到具体IP的过程就是DNS解析。</p> <p>当然，值得注意的是，浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过DNS解析。</p> <p>另外，如果不指定端口的话，默认采用对应的IP的80端口。</p> <p><strong>4. 建立TCP连接</strong></p> <p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p> <p>Chrome在同一个域名下要求同时最多只能有6个TCP连接，超过6个的话剩下的请求就得等待。</p> <p>假设现在不需要等待，我们进入了TCP连接的建立阶段。</p> <p>建立TCP连接经历了下面三个阶段:</p> <ol><li><p>通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。</p></li> <li><p>进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。</p></li> <li><p>断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。</p></li></ol> <p>这里就说明了TCP连接通过什么手段来保证数据传输的<em>可靠性</em>，一是<strong>三次握手</strong>确认连接，二是<strong>数据包校验</strong>保证数据到达接收方，三是通过<strong>四次挥手</strong>断开连接。</p> <p>关于TCP相关的详细介绍：<a href="/computer/tcp/">TCP</a></p> <p><strong>5. 发送http请求</strong></p> <p>现在TCP连接建立完毕，浏览器可以和服务器开始通信，即开始发送HTTP请求。浏览器发HTTP请求要携带三样东西：请求行、请求头和请求体。</p> <p>首先，浏览器会向服务器发送请求行，关于请求行，我们在这一部分的第一步就构建完了，贴一下内容：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span>
<span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
</code></pre></div><p>结构很简单，由请求方法、请求URI和HTTP版本协议组成。</p> <p>同时也要带上请求头，比如我们之前说的Cache-Control、If-Modified-Since、If-None-Match都由可能被放入请求头中作为缓存的标识信息。当然了还有一些其他的属性，列举如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>Accept: text/html,application/xhtml+xml,application/xml<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>,image/webp,image/apng,*/*<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.8</span>,application/signed-exchange<span class="token punctuation">;</span><span class="token assign-left variable">v</span><span class="token operator">=</span>b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>
Cache-Control: no-cache
Connection: keep-alive
Cookie: /* 省略cookie信息 */
Host: www.baidu.com
Pragma: no-cache
Upgrade-Insecure-Requests: <span class="token number">1</span>
User-Agent: Mozilla/5.0 <span class="token punctuation">(</span>iPhone<span class="token punctuation">;</span> CPU iPhone OS 11_0 like Mac OS X<span class="token punctuation">)</span> AppleWebKit/604.1.38 <span class="token punctuation">(</span>KHTML, like Gecko<span class="token punctuation">)</span> Version/11.0 Mobile/15A372 Safari/604.1
</code></pre></div><p>最后是请求体，请求体只有在POST方法下存在，常见的场景是表单提交。</p> <h3 id="网络响应"><a href="#网络响应" class="header-anchor">#</a> 网络响应</h3> <p>HTTP请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p> <p>跟请求部分类似，网络响应具有三个部分：响应行、响应头和响应体。</p> <p>响应行类似下面这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span>
</code></pre></div><p>由HTTP协议版本、状态码和状态描述组成。</p> <p>响应头包含了服务器及其返回数据的一些信息，服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。</p> <div class="language- extra-class"><pre class="language-text"><code>Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com

</code></pre></div><p>响应完成之后怎么办？TCP连接就断开了吗？</p> <p>不一定。这时候要判断Connection字段, 如果请求头或响应头中包含<code>Connection: Keep-Alive</code>，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。</p> <p>否则断开TCP连接, 请求-响应流程结束。</p> <p>浏览器端的网络请求过程：</p> <p><img src="/assets/img/network.263d4b9a.png" alt="network"></p> <h2 id="解析过程"><a href="#解析过程" class="header-anchor">#</a> 解析过程</h2> <p>完成了网络请求和响应，如果响应头中<code>Content-Type=text/html</code>，那么接下来就是浏览器的解析和渲染工作了。</p> <p><strong>主要分为以下几个步骤：</strong></p> <ul><li>构建DOM树</li> <li>样式计算</li> <li>生成布局树(Layout Tree)</li></ul> <h3 id="构建dom树"><a href="#构建dom树" class="header-anchor">#</a> 构建DOM树</h3> <p>由于浏览器无法直接理解HTML字符串，因此将这一系列的<em>字节流</em>转换为一种有意义并且方便操作的数据结构，这种数据结构就是<strong>DOM树</strong>。</p> <p>DOM树本质上是一个以document为根节点的多叉树。</p> <p>解析算法：</p> <p>HTML5规范详细地介绍了解析算法。这个算法分为两个阶段:</p> <ul><li>标记化</li> <li>建树</li></ul> <p>对应的两个过程就是<em>词法分析</em>和<em>语法分析</em>。</p> <p><strong>标记化算法</strong></p> <p>这个算法输入为HTML文本，输出为HTML标记，也成为标记生成器。其中运用有限自动状态机来完成。即在当前状态下，接收一个或多个字符，就会更新到下一个状态。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello sanyuan
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>通过一个简单的例子来演示一下标记化的过程。</p> <p>遇到<code>&lt;</code>，状态为标记打开。</p> <p>接收<code>[a-z]</code>的字符，会进入标记名称状态。</p> <p>这个状态一直保持，直到遇到<code>&gt;</code>，表示标记名称记录完成，这时候变为数据状态。</p> <p>接下来遇到body标签做同样的处理。</p> <p>这个时候html和body的标记都记录好了。</p> <p>现在来到<code>&lt;body&gt;</code>中的<code>&gt;</code>，进入数据状态，之后保持这样状态接收后面的字符<code>hello sanyuan</code>。</p> <p>接着接收<code>&lt;/body&gt;</code>中的<code>&lt;</code>，回到标记打开，接收下一个<code>/</code>后，这时候会创建一个<code>end tag</code>的token。</p> <p>随后进入标记名称状态, 遇到<code>&gt;</code>回到数据状态。</p> <p>接着以同样的样式处理<code>&lt;/html&gt;</code>。</p> <p><strong>建树算法</strong></p> <p>之前提到过，<em>DOM树</em>是一个以document为根节点的多叉树。因此解析器首先会创建一个document对象。标记生成器会把每个标记的信息发送给<em>建树器</em>。<em>建树器</em>接收到相应的标记时，会创建对应的DOM对象。创建这个DOM对象后会做两件事情:</p> <ul><li>将DOM对象加入DOM树中。</li> <li>将对应标记压入存放开放(与闭合标签意思对应)元素的栈中。</li></ul> <p>还是拿下面这个例子说:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    Hello sanyuan
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>首先，状态为<strong>初始化状态</strong>。</p> <p>接收到<em>标记生成器</em>传来的html标签，这时候状态变为<code>before html</code>状态。同时创建一个HTMLHtmlElement的DOM元素，将其加到document根对象上，并进行压栈操作。</p> <p>接着状态自动变为<code>before head</code>，此时从<em>标记生成器</em>那边传来body，表示并没有head，这时候建树器会自动创建一个HTMLHeadElement并将其加入到DOM树中。</p> <p>现在进入到<code>in head</code>状态，然后直接跳到<code>after head</code>。</p> <p>现在<em>标记生成器</em>传来了body标记，创建HTMLBodyElement，插入到DOM树中，同时压入开放标记栈。</p> <p>接着状态变为<code>in body</code>，然后来接收后面一系列的字符：<code>Hello sanyuan</code>。</p> <p>接收到第一个字符的时候，会创建一个Text节点并把字符插入其中，然后把Text节点插入到 DOM树中body元素的下面。</p> <p>随着不断接收后面的字符，这些字符会附在Text节点上。</p> <p>现在，标记生成器传过来一个body的结束标记，进入到<code>after body</code>状态。</p> <p>标记生成器最后传过来一个html的结束标记, 进入到<code>after html</code>的状态，表示解析过程到此结束。</p> <p><strong>容错机制</strong></p> <p>讲到HTML5规范，就不得不说它强大的宽容策略，容错能力非常强，虽然大家褒贬不一，不过我想作为一名资深的前端工程师，有必要知道<code>HTML Parser</code>在容错方面做了哪些事情。</p> <p>WebKit中一些经典的容错示例：</p> <ol><li>使用<code>&lt;/br&gt;</code>而不是<code>&lt;br&gt;</code></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">isCloseTag</span><span class="token punctuation">(</span>brTag<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> m_document<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">inCompatMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">reportError</span><span class="token punctuation">(</span>MalformedBRError<span class="token punctuation">)</span><span class="token punctuation">;</span>
  t<span class="token operator">-</span><span class="token operator">&gt;</span>beginTag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>全部换为<code>&lt;br&gt;</code>的形式。</p> <ol start="2"><li>表格离散</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>inner table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>outer table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>WebKit会自动转换为:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>outer table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>inner table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="3"><li>表单元素嵌套</li></ol> <p>这时候直接忽略里面的form，即form里面还有form的话，忽略里面的form。</p> <h3 id="样式计算"><a href="#样式计算" class="header-anchor">#</a> 样式计算</h3> <p>关于CSS样式，它的来源一般是三种：</p> <ul><li>link标签引用</li> <li>style标签中的样式</li> <li>元素的内嵌style属性</li></ul> <p><strong>格式化样式表</strong></p> <p>首先，浏览器是无法直接识别CSS样式文本的，因此渲染引擎接收到CSS文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。</p> <p>这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。</p> <p>在浏览器控制台能够通过<code>document.styleSheets</code>来查看这个最终的结构。当然，这个结构包含了以上三种CSS来源，为后面的样式操作提供了基础。</p> <p><strong>标准化样式属性</strong></p> <p>有一些CSS样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如<code>em-&gt;px,red-&gt;#ff0000,bold-&gt;700</code>等等。</p> <p><strong>计算每个节点的具体样式</strong></p> <p>样式已经被格式化和标准化，接下来就可以计算每个节点的具体样式信息了。</p> <p>计算的方式主要就是两个规则: <strong>继承和层叠</strong>。</p> <p>每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则。</p> <p>然后是层叠规则，CSS最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象，具体的层叠规则属于深入CSS语言的范畴，可以看《CSS世界》了解。</p> <h3 id="生成布局树"><a href="#生成布局树" class="header-anchor">#</a> 生成布局树</h3> <p>现在已经生成了<em>DOM树</em>和<em>DOM样式</em>，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。</p> <p>布局树生成的大致工作如下：</p> <ul><li>遍历生成的DOM树节点，并把他们添加到布局树中。</li> <li>计算布局树节点的坐标位置。</li></ul> <p>值得注意的是，这棵布局树只包含可见元素，对于head标签和设置了<code>display: none</code>的元素，将不会被放入其中。
有人说首先会生成<code>Render Tree</code>，也就是渲染树，其实这还是16年之前的事情，现在 Chrome团队已经做了大量的重构，已经没有生成<code>Render Tree</code>的过程了。而布局树的信息已经非常完善，完全拥有<code>Render Tree</code>的功能。</p> <p>布局的细节，过于复杂，不过大部分情况下我们只需要知道它所做的工作是什么即可，深入其中的原理可以看<a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener noreferrer">从Chrome源码看浏览器如何layout布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p><strong>解析算法的脉络</strong></p> <p><img src="/assets/img/tree.8b79f484.png" alt="tree"></p> <h2 id="渲染过程"><a href="#渲染过程" class="header-anchor">#</a> 渲染过程</h2> <p>分为以下几个步骤：</p> <ul><li>建立图层树(Layer Tree)</li> <li>生成绘制列表</li> <li>生成图块并栅格化</li> <li>显示器显示内容</li></ul> <h3 id="建图层树"><a href="#建图层树" class="header-anchor">#</a> 建图层树</h3> <p>虽然现在DOM节点有了，样式和位置信息也都有了，但是仍然不能开始绘制页面。</p> <p>因为还需要考虑另外一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等。</p> <p>为了解决如上所述的问题，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树(Layer Tree)。</p> <p>一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为合成层)。那什么时候会提升为一个单独的合成层呢？</p> <p>一种是显式合成，一种是隐式合成。</p> <p><strong>显式合成</strong></p> <ol><li>拥有层叠上下文的节点。</li></ol> <p>层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:</p> <ul><li>HTML根元素本身就具有层叠上下文</li> <li>普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文</li> <li>元素的opacity值不是 1</li> <li>元素的transform值不是none</li> <li>元素的filter值不是none</li> <li>元素的isolation值是isolate</li> <li>will-change指定的属性值为上面任意一个</li></ul> <ol start="2"><li>需要剪裁的地方。</li></ol> <p>比如一个div，只给他设置<code>100 * 100</code>像素的大小，而在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。</p> <p><strong>隐式合成</strong></p> <p>简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层。</p> <p>这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个<code>z-index</code>比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是<strong>层爆炸</strong>的原理。<a href="https://segmentfault.com/a/1190000014520786" target="_blank" rel="noopener noreferrer">详细介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="生成绘制列表"><a href="#生成绘制列表" class="header-anchor">#</a> 生成绘制列表</h3> <p>接下来<em>渲染引擎</em>会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。</p> <p>这里以百度首页为例，在Chrome开发者工具中在设置栏中展开<code>more tools</code>, 然后选择Layers面板，就能看到下面的绘制列表:</p> <p><img src="/assets/img/baidu.3a86d349.png" alt="baidu"></p> <h3 id="生成图块和生成位图"><a href="#生成图块和生成位图" class="header-anchor">#</a> 生成图块和生成位图</h3> <p>现在开始绘制操作，实际上在<em>渲染进程</em>中绘制操作是由专门的线程来完成的，这个线程叫<strong>合成线程</strong>。</p> <p>绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。</p> <p>接下来就是合成线程一展宏图的时候啦：</p> <p>首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将<em>图层分块</em>。</p> <p>这些块的大小一般不会特别大，通常是<code>256*256</code>或者<code>512*512</code>这个规格。这样可以大大加速页面的首屏展示。</p> <p>因为后面图块数据要进入GPU内存，考虑到浏览器内存上传到GPU内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是Chrome底层优化首屏加载速度的一个手段。</p> <p>渲染进程中专门维护了一个<em>栅格化线程池</em>，专门负责把图块转换为位图数据。然后合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图。</p> <p>生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发送给合成线程。</p> <h3 id="显示器显示内容"><a href="#显示器显示内容" class="header-anchor">#</a> 显示器显示内容</h3> <p>栅格化操作完成后，合成线程会生成一个绘制命令，即&quot;DrawQuad&quot;，并发送给浏览器进程。</p> <p>浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到<em>内存</em>，也就是生成了页面，然后把这部分内存发送给<em>显卡</em>。</p> <p>为什么发给显卡呢？应为显示器显示图像的原理。</p> <p>无论是PC显示器还是手机屏幕，都有一个固定的刷新频率，一般是60HZ，即60帧，也就是一秒更新60张图片，一张图片停留的时间约为16.7ms。</p> <p>每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。</p> <p>当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。</p> <p><strong>渲染过程图</strong></p> <p><img src="/assets/img/render.71e7b33a.png" alt="render"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/browser/basics/repaint/">
        重绘和回流
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5fc96bdf.js" defer></script><script src="/assets/js/2.56cd01f5.js" defer></script><script src="/assets/js/12.644b56f9.js" defer></script>
  </body>
</html>
